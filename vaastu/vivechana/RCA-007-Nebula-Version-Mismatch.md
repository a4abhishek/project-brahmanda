# RCA-007: Nebula Version Mismatch & Certificate Banner Error

- **Date of Incident:** 2026-01-22
- **Severity:** High (Blocked Nebula mesh establishment)
- **Status:** Resolved
- **Components:** Ansible, `trozz.ansible_nebula` role, Nebula binaries

## 1. The Incident (Ghatana)

- **Summary:** During the bootstrapping of the `vyom` cluster, the Nebula configuration verification step failed on all nodes with the error: `error while unmarshaling pki.cert ...: bytes did not contain a proper nebula certificate banner`. This persisted despite confirming the certificate files were valid, identical to the source, and had correct line endings.
- **Impact:** The Nebula mesh service could not start, preventing secure networking between nodes.
- **Detection:** The `ansible-playbook` run failed at the `Verify configuration` task with a non-zero return code from `nebula -test`.

## 2. The Timeline (Samaya-Sarni)

1. **Initial Failure:** The playbook failed with "invalid certificate banner".
2. **Hypothesis 1 (Line Endings):** Suspected Windows-style CRLF line endings from 1Password injection. Applied `dos2unix` and regex filters to strip `\r`.<br>**Result:** Failure persisted.
3. **Hypothesis 2 (Double Spacing):** Suspected double newlines in the PEM blocks. Applied regex to collapse newlines. <br>**Result:** Failure persisted.
4. **Investigation:** We verified the file integrity by SCPing the failing certificate from the VM back to the control node (WSL). The local `nebula-cert` tool read it successfully. This proved the file content was valid.
5. **Root Cause Discovery:** We checked the binary versions.
    - Control Node (WSL): `nebula-cert --version` -> **1.10.0**
    - Target Node (VM): `/usr/bin/nebula-cert --version` -> **1.6.1**
6. **Resolution Attempt 1:** Tried setting `nebula_version: "v1.10.0"` in the role variables.<br>**Result:** Failed; version remained old (variable precedence issue).
7. **Resolution Attempt 2:** Moved `nebula_version` to playbook-level `vars` and added a cleanup task to delete old binaries.<br>**Result:** Success. The correct version (1.10.0) was installed, and verification passed immediately.

## 3. The Root Cause (Mula Karana)

- **The "Five Whys":**
  1. **Why did the certificate verification fail?** Because the Nebula binary on the VM could not parse the certificate.
  2. **Why couldn't it parse a valid certificate?** Because the binary version on the VM was significantly older (1.6.1) than the binary used to generate the certificate (1.10.0).
  3. **Why was the binary version old?** Because the Ansible role defaulted to an older version, and our initial attempt to override it was ignored due to variable precedence.
  4. **Why was the variable ignored?** It was defined nested under the `roles:` block, which has lower precedence than role defaults in some contexts or was simply not being picked up correctly by the role's internal logic.
  5. **Why did we assume the version was correct?** We trusted the `changed: true` status of the download task without verifying the actual installed version on the target.

- **The Observability Gap:** The error message `bytes did not contain a proper nebula certificate banner` was highly misleading, as manual inspection confirmed the banner was present and correctly formatted. This caused a significant delay as we investigated false leads like line endings and hidden characters. The breakthrough occurred when we bypassed the target environment entirely by SCPing the certificate back to the control node (WSL). When the local `nebula-cert print -path /tmp/host.crt` read the file successfully, it proved the data was intact and shifted the focus to the **tooling**, directly leading to the discovery of the version mismatch.

- **Technical Cause:** Binary incompatibility between Nebula versions. Certificates generated by v1.10.0 (likely using newer V2 features or encoding nuances) were rejected by the v1.6.1 binary.

## 4. The Resolution (Samadhana)

- **Immediate Fix:**
    1. **Force Version:** Defined `nebula_version: "1.10.0"` (without the 'v' prefix, matching the role's URL construction logic) at the top-level `vars` section of the playbook to ensure high precedence.
    2. **Force Clean Install:** Added a `pre_task` to delete `/usr/bin/nebula`, `/usr/bin/nebula-cert`, `/usr/local/bin/nebula`, and `/usr/local/bin/nebula-cert`. This forced the role to re-download the binary instead of skipping the step.

## 5. The Lessons & Prevention (Shiksha & Nivarana)

- **What did we learn?**
  1. **Verify Versions First:** When a "valid" file fails to parse, check the version of the tool reading it. Mismatches between control node and target node tools are a common source of "impossible" errors.
  2. **Trust but Verify (Ansible):** Just because a task says `changed` doesn't mean it did what you expected (e.g., it might have downloaded the *default* version again).
  3. **Variable Precedence Matters:** Defining variables at the Playbook level is safer than defining them at the Role level when you need to be absolutely sure they override defaults.
  4. **Idempotency has limits:** Sometimes you need a hard reset (deleting the binary) to force a configuration change to take effect.

- **How to prevent it in future?**
  1. **Pin Versions Everywhere:** Explicitly define tool versions in `group_vars/all` or `vars` files, rather than relying on role defaults.
  2. **Version Parity:** Ensure that local tooling (on the dev machine/WSL) matches the version being deployed to production. Add a check in `check_tools` target in Makefile if possible.

## 6. Action Items (Karya-Yojana)

- [x] Correct the Ansible playbook to enforce Nebula v1.10.0.
- [x] Document the incident (this RCA).
